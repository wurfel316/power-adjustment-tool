<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>電力調整用ツール</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #000000;
            --input-bg: #ffffff;
            --input-text: #000000;
            --border-color: #ccc;
            --step-bg: #ffffff;
            --step-title-color: #666;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #121212;
                --text-color: #e0e0e0;
                --input-bg: #2d2d2d;
                --input-text: #e0e0e0;
                --border-color: #444;
                --step-bg: #1e1e1e;
                --step-title-color: #aaa;
            }
        }

        body {
            font-family: sans-serif;
            max-width: 900px;
            margin: 40px auto;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        input,
        button {
            padding: 8px;
            margin: 5px 0;
            width: 100%;
            background-color: var(--input-bg);
            color: var(--input-text);
            border: 1px solid var(--border-color);
        }

        #result {
            margin-top: 15px;
            font-weight: bold;
        }

        canvas {
            margin-top: 20px;
            border: 1px solid var(--border-color);
        }

        .ok {
            color: green;
        }

        @media (prefers-color-scheme: dark) {
            .ok {
                color: #4cd964;
            }
        }

        .ng {
            color: red;
        }

        @media (prefers-color-scheme: dark) {
            .ng {
                color: #ff3b30;
            }
        }

        /* Classes for JS generated elements */
        .step-card {
            min-width: 350px;
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 5px;
            background-color: var(--step-bg);
        }

        .step-title {
            color: var(--step-title-color);
        }

        .final-title-ok {
            color: green;
        }

        @media (prefers-color-scheme: dark) {
            .final-title-ok {
                color: #4cd964;
            }
        }

        .final-title-ng {
            color: red;
        }

        @media (prefers-color-scheme: dark) {
            .final-title-ng {
                color: #ff3b30;
            }
        }
    </style>
</head>

<body>
    <h2>電力調整用ツール</h2>
    バッテリー出力：
    <input id="a" type="number" step="10" value="1100">
    不足電力：
    <input id="t" type="number" step="5" value="0">
    <button onclick="calc()">計算</button>
    <div id="result"></div>
    <div id="all-steps" style="display: none; margin-top: 30px;">
        <h3>計算過程表示</h3>
        <div id="steps-container" style="display: flex; gap: 20px; overflow-x: auto; padding-bottom: 10px;"></div>
    </div>
    <script>
        const STORAGE_MAX = 100000;
        const STEP = 40;

        function calc() {
            const baseA = Number(document.getElementById("a").value);
            const T0 = Number(document.getElementById("t").value);

            // 全ての計算結果を保存する配列
            const allResults = [];

            // 初回計算（制限なし）
            let result = runSimulation(baseA, T0, Infinity);
            allResults.push({ result: result, step: 0, maxPowLimit: Infinity });
            let retryCount = 0;

            // deadの場合、最大パルス段を下げて再計算
            // パルス段(p>=3)が存在する場合のみリトライ可能
            while (result.dead && result.maxPulsePow >= 3 && retryCount < 10) {
                result = runSimulation(baseA, T0, result.maxPulsePow - 1);
                retryCount++;
                allResults.push({ result: result, step: retryCount, maxPowLimit: result.maxPulsePow });
            }

            // 結果表示
            let text = "";
            text += `供給電力合計: ${result.current.toFixed(1)}<br>`;

            // 構成要素の表示（段順にソート）
            const sortedUsed = [...result.used].sort((a, b) => a.pow - b.pow);
            for (const u of sortedUsed) {
                const valStr = parseFloat(u.val.toFixed(4));
                text += `・${valStr}（= ${baseA} × 4 × 1/2^${u.pow}）<br>`;
            }
            text += `<br>`;

            text += `フラグ: ${result.bits}<br>`;
            text += `ブロック: ${result.blocks}<br>`;
            // パルス段の数値をカンマ区切りで表示
            const powList = sortedUsed.map(u => u.pow).join(",");
            text += `使用段: ${powList}<br><br>`;
            text += `最小貯蔵量: ${result.minStorage.toFixed(0)}<br>`;

            if (result.dead) {
                text += `<span class="ng">❌ 貯蔵電力が尽きます (調整限界)</span>`;
            } else if (retryCount > 0) {
                text += `<span class="ok">✅ 安定稼働します</span>`;
            } else {
                text += `<span class="ok">✅ 安定稼働します</span>`;
            }

            document.getElementById("result").innerHTML = text;

            // 全ステップ表示（常に表示）
            document.getElementById("all-steps").style.display = "block";
            const container = document.getElementById("steps-container");
            container.innerHTML = ""; // クリア

            // 表示順序の作成：最後（最終結果）を先頭に、その後は0番目から順に（ただし最後は除く）
            let displayList = [];
            if (allResults.length > 0) {
                // 最終結果
                displayList.push(allResults[allResults.length - 1]);
                // 初回〜最後の一つ前まで
                for (let i = 0; i < allResults.length - 1; i++) {
                    displayList.push(allResults[i]);
                }
            }

            displayList.forEach((item, index) => {
                const stepDiv = document.createElement("div");
                stepDiv.className = "step-card";

                const r = item.result;
                const isDead = r.dead;
                const isFinal = (item === allResults[allResults.length - 1]);

                let stepText = "";
                // タイトル生成
                if (isFinal) {
                    const titleClass = isDead ? 'final-title-ng' : 'final-title-ok';
                    stepText += `<h4 class="${titleClass}">最終結果`;
                } else {
                    stepText += `<h4 class="step-title">経過`;
                }

                if (item.step === 0) {
                    stepText += `（初回計算）</h4>`;
                } else {
                    stepText += `（リトライ #${item.step}）</h4>`;
                }

                stepText += `<div style="font-size: 0.9em;">`;
                stepText += `供給電力: ${r.current.toFixed(1)}<br>`;

                // 構成要素の表示
                const rSortedUsed = [...r.used].sort((a, b) => a.pow - b.pow);
                for (const u of rSortedUsed) {
                    const rValStr = parseFloat(u.val.toFixed(4));
                    stepText += `・${rValStr}（= ${baseA} × 4 × 1/2^${u.pow}）<br>`;
                }
                const rPowList = rSortedUsed.map(u => u.pow).join(",");
                stepText += `使用段: ${rPowList}<br>`;

                stepText += `<br>`;
                stepText += `最小貯蔵量: ${r.minStorage.toFixed(0)}<br>`;
                stepText += isDead
                    ? `<span class="ng">❌ 枯渇</span>`
                    : `<span class="ok">✅ 安定</span>`;
                stepText += `</div>`;

                stepDiv.innerHTML = stepText;

                // キャンバスを追加
                const canvas = document.createElement("canvas");
                canvas.width = 330;
                canvas.height = 180;
                canvas.style.marginTop = "10px";
                stepDiv.appendChild(canvas);

                container.appendChild(stepDiv);

                // グラフ描画
                drawGraphOnCanvas(canvas, r, 330, 180);
            });
        }

        function drawGraphOnCanvas(canvas, result, width, height) {
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, width, height);

            const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const axisColor = isDarkMode ? "#e0e0e0" : "black";

            if (result.times.length > 1) {
                // グラフのX軸範囲：シミュレーションが終了した時間（枯渇時はその時点まで）
                const maxTime = result.times[result.times.length - 1];

                ctx.beginPath();
                ctx.moveTo(0, height - (result.stores[0] / STORAGE_MAX) * height);
                for (let i = 1; i < result.times.length; i++) {
                    const x = (result.times[i] / maxTime) * width;
                    const y = height - (result.stores[i] / STORAGE_MAX) * height;
                    ctx.lineTo(x, y);
                }

                let strokeColor;
                if (result.dead) {
                    strokeColor = isDarkMode ? "#ff453a" : "red";
                } else {
                    strokeColor = isDarkMode ? "#4dabf7" : "blue";
                }

                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                ctx.stroke();

                // 右下に時間を表示
                ctx.fillStyle = axisColor;
                ctx.font = "12px sans-serif";
                ctx.textAlign = "right";
                // 右端から少し離して表示
                ctx.fillText(Math.round(maxTime) + "s", width - 5, height - 5);
            }
        }

        function runSimulation(baseA, T0, maxAllowedPow) {
            const A = baseA * 4;

            /* ===== 段選択 ===== */
            let used = [];
            let current = 0;
            let value = A / 2;
            let n = 1;

            while (value > 1) {
                // n（段数）が許容範囲内であれば追加判定
                if (n <= maxAllowedPow) {
                    if (current + value <= T0) {
                        current += value;
                        used.push({ val: value, pow: n });
                    }
                }
                value /= 2;
                n++;
            }

            /* ===== T0を下回らないよう補正 ===== */
            if (current < T0) {
                const usedPows = new Set(used.map(u => u.pow));
                // nはループ終了後の値になっているので、maxAllowedPowと比較して調整
                let extraPow = n - 1;
                // もし n-1 が maxAllowedPow を超えていたら、maxAllowedPow からスタート
                if (extraPow > maxAllowedPow) extraPow = maxAllowedPow;

                let extraVal = A / Math.pow(2, extraPow);

                while (
                    extraPow > 0 &&
                    (usedPows.has(extraPow) || current + extraVal < T0)
                ) {
                    extraPow--;
                    extraVal = A / Math.pow(2, extraPow);
                }

                if (extraPow > 0 && !usedPows.has(extraPow)) {
                    current += extraVal;
                    used.push({
                        val: extraVal,
                        pow: extraPow
                    });
                }
            }

            /* ===== 過剰分を削減する最適化 ===== */
            // 値の大きい順にソートし、削除してもT0を下回らないなら削除する
            used.sort((a, b) => b.val - a.val);
            for (let i = 0; i < used.length; i++) {
                const u = used[i];
                if (current - u.val >= T0) {
                    current -= u.val;
                    used.splice(i, 1);
                    i--; // 削除したのでインデックスを調整
                }
            }

            /* ===== フラグ・ブロック ===== */
            const powSet = new Set(used.map(u => u.pow));
            const maxPow = powSet.size ? Math.max(...powSet) : 0;
            let bits = "";
            let blocks = "";
            for (let i = 1; i <= maxPow; i++) {
                const on = powSet.has(i);
                bits += on ? "1" : "0";
                blocks += on ? "■ " : "□ ";
            }

            /* ===== ベース供給 ===== */
            let baseSupply = 0;
            if (powSet.has(1)) baseSupply += A / 2;
            if (powSet.has(2)) baseSupply += A / 4;

            /* ===== パルス段 ===== */
            const pulsePows = used.map(u => u.pow).filter(p => p >= 3);
            const maxPulsePow = pulsePows.length > 0 ? Math.max(...pulsePows) : 0;

            /* ===== 時間シミュレーション ===== */
            // 最長パルス周期を計算してシミュレーション時間とする（視覚的にわかりやすくするため2倍）
            const maxCycle = pulsePows.length > 0 ? 10 * Math.pow(2, Math.max(...pulsePows)) : 3600;
            const simTime = maxCycle * 2;

            let storage = STORAGE_MAX;
            let minStorage = storage;
            let dead = false;
            // hasDropped: 満タンから一度でも減ったかどうか
            // recovered: 減った後、再び満タンまで回復したかどうか
            let hasDropped = false;
            let recovered = false;

            const times = [];
            const stores = [];

            for (let time = 0; time <= simTime; time += STEP) {
                let supply = baseSupply;
                for (const p of pulsePows) {
                    const cycle = 10 * Math.pow(2, p);
                    if ((time % cycle) < STEP) {
                        supply += baseA;
                    }
                }
                storage += (supply - T0) * STEP;
                storage = Math.min(storage, STORAGE_MAX);
                storage = Math.max(storage, 0);
                minStorage = Math.min(minStorage, storage);

                // 満タンから減ったかをチェック
                if (storage < STORAGE_MAX) {
                    hasDropped = true;
                }
                // 減った状態から満タンに復帰したかをチェック
                else if (hasDropped && storage >= STORAGE_MAX) {
                    recovered = true;
                }

                times.push(time);
                stores.push(storage);
                if (storage <= 0) {
                    dead = true;
                    break;
                }
            }

            // シミュレーション中に一度も回復しなかった場合（ずっと減り続けている場合など）、将来的に枯渇すると判断
            // ただし、一度も減っていない（常に満タン）場合はOK
            if (!dead && hasDropped && !recovered) {
                dead = true;
            }

            return {
                current,
                used,
                bits,
                blocks,
                baseSupply,
                pulsePows,
                maxPulsePow,
                minStorage,
                dead,
                times,
                stores,
                simTime
            };
        }
    </script>
</body>

</html>